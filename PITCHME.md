# Python для сетевых инженеров 

#HSLIDE

# Ansible

#VSLIDE
### Ansible

Ansible - это система управления конфигурациями. Ansible позволяет автоматизировать и упростить настройку, обслуживание и развертывание серверов, служб, ПО и др.

На данный момент существует несколько [систем управления конфигурациями](http://xgu.ru/wiki/%D0%A1%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0_%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F_%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B0%D1%86%D0%B8%D0%B5%D0%B9).

Однако, для работы с сетевым оборудованием, чаще всего используется Ansible.
Связано это с тем, что Ansible не требует установки агента на управляемые хосты.
Особенно актуально это для устройств, которые позволяют работать с ними только через CLI.

Кроме того, Ansible активно развивается в сторону поддержки сетевого оборудования и постоянно появляются новые возможности и модули для работы с сетевым оборудованием.

#VSLIDE
### Ansible

Примеры задач, которые поможет решить Ansible:
* подключение по SSH к устройствам
 * паралелльное подключение к устройствам по SSH (можно указывать ко скольки устройствам подключаться одновременно)
* отправка команд на устройства
* удобный синтаксис описания устройств:
 * можно разбивать устройства на группы и затем отправлять какие-то команды на всю группу
* поддержка шаблонов конфигураций с Jinja2

#VSLIDE
### Установка Ansible

Ansible нужно устанавливать только на той машине, с которой будет выполняться управление устройствами.

Требования к управляющему хосту:
* поддержка Python 2.7 (или 2.6)
* Windows не может быть управляющим хостом

Ansible довольно часто обновляется, поэтому лучше установить его в виртуальном окружении.

#VSLIDE
### Установка Ansible

Установить Ansible можно [по-разному](http://docs.ansible.com/ansible/intro_installation.html#).

Например, с помощью pip:
```
$ pip install ansible==2.2.0.0
```

#VSLIDE
### Параметры оборудования

В примерах раздела используются три маршрутизатора и один коммутатор. К ним нет никаких требований, только настроенный SSH.

Параметры, которые используются в разделе:
* пользователь: cisco
* пароль: cisco
* пароль на режим enable: cisco
* SSH версии 2
* IP-адреса:
 * R1: 192.168.100.1
 * R2: 192.168.100.2
 * R3: 192.168.100.3
 * SW1: 192.168.100.100

#HSLIDE
## Основы Ansible

#VSLIDE
### Основы Ansible

* Работает без установки агента на управляемые хосты
* Использует SSH для подключения к управляемым хостам
* Выполняет изменения, с помощью модулей Python, которые выполняются на управляемых хостах
* Может выполнять действия локально, на управляющем хосте
* Использует YAML для описания сценариев
* Содержит множество модулей (их количество постоянно растет)
* Легко писать свои модули

#VSLIDE
### Терминология

* __Control machine__ —  управляющий хост. Сервер Ansible, с которого происходит управление другими хостами
* __Manage node__ —  управляемые хосты
* __Inventory__ —  инвентарный файл. В этом файле описываются хосты, группы хостов. А также могут быть созданы переменные
* __Playbook__ — файл сценариев
* __Play__ —  сценарий (набор задач). Связывает задачи с хостами, для которых эти задачи надо выполнить
* __Task__ —  задача. Вызывает модуль с указанными параметрами и переменными
* __Module__ — модуль Ansible. Реализует определенные функции


#VSLIDE
### Quick start

Минимум, который нужен для начала работы:
* инвентарный файл - в нем описываются устройства
* изменить конфигурацию Ansible, для работы с сетевым оборудованием
* разобраться с ad-hoc командами - это возможность выполнять простые действия с устройствами из командной строки
 * например, с помощью ad-hoc команд, можно отправить команду show на несколько устройств

#HSLIDE
### Инвентарный файл

#VSLIDE
### Инвентарный файл

Инвентарный файл - это файл, в котором описываются устройства, к которым Ansible будет подключаться.

В инвентарном файле устройства могут указываться используя IP-адреса или имена.
Устройства могут быть указаны по одному или разбиты на группы.

#VSLIDE
### Инвентарный файл

Файл описывается в формате INI. Пример файла:
```ini
r5.example.com

[cisco-routers]
192.168.255.1
192.168.255.2
192.168.255.3
192.168.255.4

[cisco-edge-routers]
192.168.255.1
192.168.255.2
```

#VSLIDE
### Инвентарный файл

Название, которое указано в квадратных скобках - это название группы.
В данном случае, созданы две группы устройств: cisco-routers и cisco-edge-routers.

Обратите внимание, что адреса 192.168.255.1 и 192.168.255.2 находятся в двух группах.
Это нормальная ситуация, один и тот же адрес или имя хоста, можно помещать в разные группы.

Таким образом можно применять отдельно какие-то политики для группы cisco-edge-routers, но в то же время, когда необходимо настроить что-то, что касается всех маршрутизаторов, можно использовать группу cisco-routers.

#VSLIDE
### Инвентарный файл

По умолчанию, файл находится в ```/etc/ansible/hosts```.

Но можно создавать свой инвентарный файл и использовать его.
Для этого нужно, либо указать его при запуске ansible, используя опцию ```-i <путь>```, либо указать файл в конфигурационном файле Ansible.

#VSLIDE
### Инвентарный файл

Если какое-то из устройств использует нестандартный порт SSH,
порт можно указать после имени или адреса устройства, через двоеточие (ниже показан пример).

Такой вариант указания порта работает только с подключениями OpenSSH и не работает с paramiko.

#VSLIDE
### Инвентарный файл

Пример инвентарного файла, с использованием нестандартных портов для SSH:
```ini
[cisco-routers]
192.168.255.1:22022
192.168.255.2:22022
192.168.255.3:22022

[cisco-switches]
192.168.254.1
192.168.254.2
```

#VSLIDE
### Инвентарный файл

Если в группу надо добавить несколько устройств с однотипными именами, можно использовать такой вариант записи:
```ini
[cisco-routers]
192.168.255.[1-5]
```

Такая запись означает, что в группу попадут устройства с адресами 192.168.255.1-192.168.255.5.

#VSLIDE
### Группа из групп

Ansible также позволяет объединять группы устройств в общую группу. Для этого используется специальный синтаксис:
```ini
[cisco-routers]
192.168.255.1
192.168.255.2
192.168.255.3

[cisco-switches]
192.168.254.1
192.168.254.2

[cisco-devices:children]
cisco-routers
cisco-switches
```


#HSLIDE
### Ad Hoc команды

#VSLIDE
### Ad Hoc команды

Ad-hoc команды - это возможность запустить какое-то действие Ansible из командной строки.

Такой вариант используется, как правило, в тех случаях, когда надо что-то проверить, например, работу модуля.
Или просто выполнить какое-то разовое действие, которое не нужно сохранять.

В любом случае, это простой и быстрый способ начать использовать Ansible.

#VSLIDE
### Ad Hoc команды

Сначала нужно создать в локальном каталоге инвентарный файл. Назовем его myhosts:
```
[cisco-routers]
192.168.100.1
192.168.100.2
192.168.100.3

[cisco-switches]
192.168.100.100
```

#VSLIDE
### Ad Hoc команды

При подключении к устройствам первый раз, сначала лучше подключиться к ним вручную, чтобы ключи устройств были сохранены локально. В Ansible есть возможность отключить эту первоначальную проверку ключей. В разделе о конфигурационном файле мы посмотрим как это делать (такой вариант может понадобиться, если надо подключаться к большому количеству устройств).

Пример ad-hoc команды:
```
$ ansible cisco-routers -i myhosts -m raw -a "sh ip int br" -u cisco --ask-pass
```

#VSLIDE
### Ad Hoc команды

Разберемся с параметрами команды:
* ```cisco-routers``` - группа устройств, к которым нужно применить действия
 * эта группа должна существовать в инвентарном файле
 * это может быть конкретное имя или адрес
 * если нужно указать все хосты из файла, можно использовать значение all или *
 * Ansible поддерживает более сложные варианты указания хостов, с регулярными выражениями и разными шаблонами. Подробнее об этом в [документации](http://docs.ansible.com/ansible/intro_patterns.html)

#VSLIDE
### Ad Hoc команды

* ```-i myhosts``` - параметр -i позволяет указать инвентарный файл
* ```-m raw -a "sh ip int br"``` - параметр ```-m raw``` означает, что используется модуль raw
 * этот модуль позволяет отправлять команды в SSH сессии, но при этом не загружает на хост модуль Python. То есть, этот модуль просто отправляет указанную команду как строку и всё
 * плюс модуля raw в том, что он может использоваться для любой системы, которую поддерживает Ansible
 * ```-a "sh ip int br"``` - параметр ```-a``` указывает какую команду отправить

#VSLIDE
### Ad Hoc команды

* ```-u cisco``` - подключение выполняется от имени пользователя cisco
* ```--ask-pass``` - параметр который нужно указать, чтобы аутентификация была по паролю, а не по ключам

#VSLIDE
### Ad Hoc команды

Результат выполнения будет таким:
```
$ ansible cisco-routers -i myhosts -m raw -a "sh ip int br" -u cisco --ask-pass
```

![ad-hoc-fail](https://raw.githubusercontent.com/natenka/PyNEng/master/images/15_ansible/2_ad-hoc-fail.png)

#VSLIDE
### Ad Hoc команды

Ошибка значит, что нужно установить программу sshpass.
Эта особенность возникает только когда используется аутентификацию по паролю.

Установка sshpass:
```
$ sudo apt-get install sshpass
```

#VSLIDE
### Ad Hoc команды

Команду надо выполнить повторно:
```
$ ansible cisco-routers -i myhosts -m raw -a "sh ip int br" -u cisco --ask-pass
```

#VSLIDE

Результат выполнения команды
![ad-hoc](https://raw.githubusercontent.com/natenka/PyNEng/master/images/15_ansible/1_ad-hoc.png)


#HSLIDE

### Конфигурационный файл

#VSLIDE
### Конфигурационный файл

Настройки Ansible можно менять в конфигурационном файле.

Конфигурационный файл Ansible может хранится в разных местах (файлы перечислены в порядке уменьшения приоритетности):
* ANSIBLE_CONFIG (переменная окружения)
* ansible.cfg (в текущем каталоге)
* .ansible.cfg (в домашнем каталоге пользователя)
* /etc/ansible/ansible.cfg

Ansible ищет файл конфигурации в указанном порядке и использует первый найденный (конфигурация из разных файлов не совмещается).

#VSLIDE
### Конфигурационный файл

В конфигурационном файле можно менять множество параметров.
Полный список параметров и их описание, можно найти в [документации](http://docs.ansible.com/ansible/intro_configuration.html).

В текущем каталоге должен быть инвентарный файл myhosts:
```
[cisco-routers]
192.168.100.1
192.168.100.2
192.168.100.3

[cisco-switches]
192.168.100.100
```

#VSLIDE
### Конфигурационный файл

В текущем каталоге надо создать такой конфигурационный файл ansible.cfg:
```
[defaults]

inventory = ./myhosts
remote_user = cisco
ask_pass = True
```

#VSLIDE
### Конфигурационный файл

Настройки в конфигурационном файле:
* ```[defaults]``` - секция описывает общие параметры по умолчанию
* ```inventory = ./myhosts``` - местоположение инвентарного файла
* ```remote_user = cisco``` - от имени какого пользователя будет подключаться Ansible
* ```ask_pass = True``` - этот параметр аналогичен опции --ask-pass в командной строке

#VSLIDE
### Конфигурационный файл

Теперь вызов ad-hoc команды будет выглядеть так:
```
$ ansible cisco-routers -m raw -a "sh ip int br"
```

Теперь не нужно указывать инвентарный файл, пользователя и опцию --ask-pass.


#VSLIDE
### gathering

По умолчанию, Ansible собирает факты об устройствах.

Факты - это информация о хостах, к которым подключается Ansible.
Эти факты можно использовать в playbook и шаблонах как переменные.

Сбором фактов, по умолчанию, занимается модуль [setup](http://docs.ansible.com/ansible/setup_module.html).

Но, для сетевого оборудования, модуль setup не подходит, поэтому сбор фактов надо отключить.
Это можно сделать в конфигурационном файле Ansible или в playbook.

#VSLIDE
### gathering

Для сетевого оборудования нужно использовать отдельные модули для сбора фактов (если они есть).

Отключение сбора фактов в конфигурационном файле:
```yml
gathering = explicit
```


#VSLIDE
### host_key_checking

Параметр host_key_checking отвечает за проверкy ключей, при подключении по SSH.
Если указать в конфигурационном файле ```host_key_checking=False```, проверка будет отключена.

Это полезно, когда с управляющего хоста Ansible надо подключиться к большому количеству устройств первый раз.

Чтобы проверить этот функционал, надо удалить сохраненные ключи для устройств Cisco, к которым уже выполнялось подкление.
В линукс они находятся в файле ~/.ssh/known_hosts.

#VSLIDE
### host_key_checking

Если выполнить ad-hoc команду, после удаления ключей, вывод будет таким:
```
$ ansible cisco-routers -m raw -a "sh ip int br"
```

![host_key_checking](https://raw.githubusercontent.com/natenka/PyNEng/master/images/15_ansible/host_key_checking.png)


#VSLIDE
### host_key_checking

Добавляем в конфигурационный файл параметр host_key_checking:
```
[defaults]

inventory = ./myhosts

remote_user = cisco
ask_pass = True

host_key_checking=False
```

#VSLIDE
### host_key_checking

И повторим ad-hoc команду:
```
$ ansible cisco-routers -m raw -a "sh ip int br"
```

#VSLIDE
Результат выполнения команды:

![host_key_checking2](https://raw.githubusercontent.com/natenka/PyNEng/master/images/15_ansible/host_key_checking2.png)

#VSLIDE
### host_key_checking

Обратите внимание на строки:
```
 Warning: Permanently added '192.168.100.1' (RSA) to the list of known hosts.
```

Ansible сам добавил ключи устройств в файл ~/.ssh/known_hosts.
При подключении в следующий раз этого сообщения уже не будет.


Другие параметры конфигурационного файла можно посмотреть в документации.
Пример конфигурационного файла в [репозитории Ansible](https://github.com/ansible/ansible/blob/devel/examples/ansible.cfg).

#HSLIDE

### Модули Ansible

#VSLIDE
### Модули Ansible

Вместе с установкой Ansible устанавливается также большое количество модулей (библиотека модулей).
В текущей библиотеке модулей, находится порядка 200 модулей.

Модули отвечают за действия, которые выполняет Ansible.
При этом, каждый модуль, как правило, отвечает за свою конкретную и небольшую задачу.

Модули можно выполнять отдельно, в ad-hoc командах или собирать в определенный сценарий (play), а затем в playbook.

#VSLIDE
### Модули Ansible

Как правило, при вызове модуля, ему нужно передать аргументы.
Какие-то аргументы будут управлять поведением и параметрами модуля, а какие-то передавать, например, команду, которую надо выполнить.

Например, мы уже выполняли ad-hoc команды, используя модуль raw. И передавали ему аргументы:
```
$ ansible cisco-routers -i myhosts -m raw -a "sh ip int br" -u cisco --ask-pass
```

#VSLIDE
### Модули Ansible

Выполнение такой же задачи в playbook будет выглядеть так (playbook рассматривается в следующем разделе):
```
    - name: run sh ip int br        
      raw: sh ip int br | ex unass
```

После выполнения, модуль возвращает результаты выполнения в формате JSON.

#VSLIDE
### Модули Ansible

Модули Ansible, как правило, идемпотентны.
Это означает, что модуль можно выполнять сколько угодно раз, но при этом модуль будет выполнять изменения, только если система не находится в желаемом состоянии.

#VSLIDE
### Модули Ansible

В Ansible модули разделены на две категории:
* __core__ - это модули, которые всегда устанавливаются вместе с Anible. Их поддерживает основная команда разработчиков Ansible.
* __extra__ - это модули на данный момент устанавливаются с Ansible, но нет гарантии, что они и дальше будут устанавливаться с Ansible. Возможно, в будущем, их нужно будет устанавливать отдельно. Большинство этих модулей поддерживаются сообществом.

Также в Ansible модули разделены по функциональности.
Список всех категорий находится в [документации](http://docs.ansible.com/ansible/modules_by_category.html).


#HSLIDE
## Основы playbooks

#VSLIDE
### Основы playbooks

Playbook (файл сценариев) — это файл в котором описываются действия, которые нужно выполнить на какой-то группе хостов.

Внутри playbook:
* play - это набор задач, которые нужно выполнить для группы хостов
* task - это конкретная задача. В задаче есть, как минимум:
 * описание (название задачи можно не писать, но очень рекомендуется)
 * модуль и команда (действие в модуле)


#VSLIDE
### Синтаксис playbook

Пример plabook 1_show_commands_with_raw.yml:
```
- name: Run show commands on routers
  hosts: cisco-routers
  gather_facts: false

  tasks:

    - name: run sh ip int br        
      raw: sh ip int br | ex unass

    - name: run sh ip route
      raw: sh ip route

- name: Run show commands on switches
  hosts: cisco-switches
  gather_facts: false

  tasks:

    - name: run sh int status
      raw: sh int status

    - name: run sh vlan
      raw: show vlan
```

#VSLIDE

И тот же playbook с отображением элементов:

![Ansible playbook](https://raw.githubusercontent.com/natenka/PyNEng/master/images/15_ansible/playbook.png)

#VSLIDE
### Синтаксис playbook

Так выглядит выполнение playbook:
```
$ ansible-playbook 1_show_commands_with_raw.yml
```

#VSLIDE
Так выглядит выполнение playbook:

![Ansible playbook](https://raw.githubusercontent.com/natenka/PyNEng/master/images/15_ansible/playbook_execution.png)

#VSLIDE
### Синтаксис playbook

Запуск playbook с опцией -v (вывод сокращен):
```
$ ansible-playbook 1_show_commands_with_raw.yml -v
```

![Verbose playbook](https://raw.githubusercontent.com/natenka/PyNEng/master/images/15_ansible/playbook-verbose.png)


#VSLIDE
### Порядок выполнения задач и сценариев

Сценарии (play) и задачи (task) выполняются последовательно, в том порядке, в котором они описаны в playbook.

Если в сценарии, например, две задачи, то сначала первая задача должна быть выполнена для всех устройств, которые указаны в параметре hosts.
Только после того, как первая задача была выполнена для всех хостов, начинается выполнение второй задачи.

Если в ходе выполнения playbook, возникла ошибка в задаче на каком-то устройстве, это устройство исключается, и другие задачи на нем выполняться не будут.

#VSLIDE
### Порядок выполнения задач и сценариев

Например, заменим пароль пользователя cisco на cisco123 (правильный cisco) на маршрутизаторе 192.168.100.1, и запустим playbook заново:
```
$ ansible-playbook 1_show_commands_with_raw.yml
```

#VSLIDE

![Ansible playbook](https://raw.githubusercontent.com/natenka/PyNEng/master/images/15_ansible/playbook_failed_execution.png)

#VSLIDE
### Порядок выполнения задач и сценариев

Обратите внимание на ошибку в выполнении первой задачи для маршрутизатора 192.168.100.1.

Во второй задаче 'TASK [run sh ip route]', Ansible уже исключил маршрутизатор и выполняет задачу только для маршрутизаторов 192.168.100.2 и 192.168.100.3.

#VSLIDE
### Порядок выполнения задач и сценариев

Еще один важный аспект - Ansible выдал сообщение:
```
to retry, use: --limit @/home/nata/pyneng_course/chapter15/1_show_commands_with_raw.retry
```
#VSLIDE
### Порядок выполнения задач и сценариев

Если, при выполнении playbook, на каком-то устройстве возникла ошибка, Ansible создает специальный файл, который называется точно так же как playbook, но расширение меняется на retry.
(Если вы выполняете задания параллельно, то этот файл должен появится у вас)

В этом файле хранится имя или адрес устройства на котором возникла ошибка.
Так выглядит файл 1_show_commands_with_raw.retry сейчас:
```
192.168.100.1
```

#VSLIDE
### Порядок выполнения задач и сценариев

Создается этот файл для того, чтобы можно было перезапустить playbook заново только для проблемного устройства (устройств).
То есть, надо исправить проблему с устройством, и заново запустить playbook.

#VSLIDE
### Порядок выполнения задач и сценариев

Настраиваем правильный пароль на маршрутизаторе 192.168.100.1, а затем перезапускаем playbook таким образом:
```
$ ansible-playbook 1_show_commands_with_raw.yml --limit @/home/nata/pyneng_course/chapter15/1_show_commands_with_raw.retry
```

![Ansible playbook](https://raw.githubusercontent.com/natenka/PyNEng/master/images/15_ansible/playbook-retry.png)

#VSLIDE
### Порядок выполнения задач и сценариев

Ansible взял список устройств, которые перечислены в файле retry и выполнил playbook только для них.

Можно было запустить playbook и так (то есть, писать не полный путь к файлу retry):
```
$ ansible-playbook 1_show_commands_with_raw.yml --limit @1_show_commands_with_raw.retry
```

#VSLIDE
### Параметр --limit

Параметр --limit очень полезная вещь.
Он позволяет ограничивать, для каких хостов или групп будет выполняться playbook, при этом, не меняя сам playbook.

Например, таким образом playbook запустить только для маршрутизатора 192.168.100.1:
```
$ ansible-playbook 1_show_commands_with_raw.yml --limit 192.168.100.1
```

#VSLIDE

### Идемпотентность

Модули Ansible идемпотентны.
Это означает, что модуль можно выполнять сколько угодно раз, но при этом модуль будет выполнять изменения, только если система не находится в желаемом состоянии.

Но, есть исключения из такого поведения.
Например, модуль raw всегда вносит изменения.
Поэтому в выполнении playbook выше, всегда отоброжалось состояние changed.

#VSLIDE

### Идемпотентность

Но, если, например, в задаче указано, что на сервер Linux надо установить пакет httpd, то он будет установлен только в том случае, если его нет.
То есть, действие не будет повторяться снова и снова, при каждом запуске.
А лишь тогда, когда пакета нет.

Аналогично, и с сетевым оборудованием.
Если задача модуля выполнить команду в конфигурационном режиме, а она уже есть на устройстве, модуль не будет вносить изменения.


#HSLIDE
### Переменные

#VSLIDE
### Переменные

Переменной может быть, например:
* информация об устройстве, которая собрана как факт, а затем используется в шаблоне.
* в переменные можно записывать полученный вывод команды.
* переменная может быть указана вручную в playbook

#VSLIDE
### Имена переменных

В Ansible есть определенные ограничения по формату имен переменных:
* Переменные могут состоять из букв, чисел и символа ```_```
* Переменные должны начинаться с буквы

#VSLIDE
### Имена переменных

Кроме того, можно создавать словари с переменными (в формате YAML):
```
R1:
  IP: 10.1.1.1/24
  DG: 10.1.1.100
```

#VSLIDE
### Имена переменных

Обращаться к переменным в словаре можно двумя вариантами:
```
R1['IP']
R1.IP
```

Правда, при использовании второго варианта, могут быть проблемы, если название ключа совпадает с зарезервированным словом (методом или атрибутом) в Python или Ansible.

#VSLIDE
### Где можно определять переменные

Переменные можно создавать:
* в инвентарном файле
* в playbook
* в специальных файлах для группы/устройства
* в отдельных файлах, которые добавляются в playbook через include (как в Jinja2)
* в ролях, которые затем используются
* можно даже передавать переменные при вызове playbook

Также можно использовать факты, которые были собраны про устройство, как переменные.


#VSLIDE
### Переменные в инвентарном файле

В инвентарном файле можно указывать переменные для группы:
```
[cisco-routers]
192.168.100.1
192.168.100.2
192.168.100.3

[cisco-switches]
192.168.100.100

[cisco-routers:vars]
ntp_server=192.168.255.100
log_server=10.255.100.1
```

#VSLIDE
### Переменные в playbook

Переменные можно задавать прямо в playbook. Это может быть удобно тем, что переменные находятся там же, где все действия.

```
- name: Run show commands on routers
  hosts: cisco-routers
  gather_facts: false

  vars:
    ntp_server: 192.168.255.100
    log_server: 10.255.100.1

  tasks:

    - name: run sh ip int br        
      raw: sh ip int br | ex unass

    - name: run sh ip route
      raw: sh ip route

```

#VSLIDE
### Переменные в специальных файлах для группы/устройства

Ansible позволяет хранить переменные для группы/устройства в специальных файлах:
* Для групп устройств, переменные должны находится в каталоге group_vars, в файлах, которые называются, как имя группы.
 * Кроме того, можно создавать в каталоге group_vars файл all, в котором будут находиться переменные, которые относятся ко всем группам.
* Для конкретных устройств, переменные должны находится в каталоге host_vars, в файлах, которые соответствуют имени или адресу хоста.
* Все файлы с переменными, должны быть в формате YAML. Расширение файла может быть таким: yml, yaml, json или без расширения
* каталоги group_vars и host_vars должны находиться в том же каталоге, что и playbook. Или могут находиться внутри каталога inventory (первый вариант более распространенный).
 * если каталоги и файлы названы правильно и расположены в указанных каталогах, Ansible сам разпознает файлы и будет использовать переменные

#VSLIDE
### Переменные в специальных файлах для группы/устройства

Например, если инвентарный файл myhosts выглядит так:
```
[cisco-routers]
192.168.100.1
192.168.100.2
192.168.100.3

[cisco-switches]
192.168.100.100
```

#VSLIDE
### Переменные в специальных файлах для группы/устройства

Можно создать такую структуру каталогов:
```
├── group_vars                 _
│   ├── all.yml                 |
│   ├── cisco-routers.yml       |  Каталог с переменными для групп устройств
│   └── cisco-switches.yml     _|
|
├── host_vars                  _
│   ├── 192.168.100.1           |
│   ├── 192.168.100.2           |
│   ├── 192.168.100.3           |  Каталог с переменными для устройств 
│   └── 192.168.100.100        _|
|
└── myhosts                     |  Инвентарный файл
```

Ниже пример содержимого файлов переменных для групп устройств и для отдельных хостов.

#VSLIDE
### Переменные в специальных файлах для группы/устройства

group_vars/all.yml (в этом файле указываются значения по умолчанию, которые относятся ко всем устройствам):
```
cli:
  host: "{{ inventory_hostname }}"
  username: "cisco"
  password: "cisco"
  transport: cli
  authorize: yes
  auth_pass: "cisco"

```

#VSLIDE
### Переменные в специальных файлах для группы/устройства

В файле group_vars/all.yml создан словарь cli.
В этом словаре перечислены те аргументы, которые должны задаваться для работы с сетевым оборудованием через встроенные модули Ansible

Интересный момент в этом файле - переменная host: "{{ inventory_hostname }}":
* inventory_hostname - это специальная переменная, которая указывает на тот хост, для которого Ansible выполняет действия.
* синтаксис {{ inventory_hostname }} - это подстановка переменных. Используется формат Jinja

#VSLIDE
### Переменные в специальных файлах для группы/устройства

group_vars/cisco-routers.yml
```
---

log_server: 10.255.100.1
ntp_server: 10.255.100.1
users:
  user1: pass1
  user2: pass2
  user3: pass3
```

#VSLIDE
### Переменные в специальных файлах для группы/устройства

group_vars/cisco-switches.yml
```
---

vlans:
  - 10
  - 20
  - 30
```

#VSLIDE
### Переменные в специальных файлах для группы/устройства

Файлы с переменными для хостов однотипны и в них меняются только адреса и имена:

Файл host_vars/192.168.100.1
```
---

hostname: london_r1
mgmnt_loopback: 100
mgmnt_ip: 10.0.0.1
ospf_ints:
  - 192.168.100.1
  - 10.0.0.1
  - 10.255.1.1
```

#VSLIDE
### Приоритетность переменных

Чаще всего, переменная с определенным именем только одна.
Но, иногда может понадобиться создать переменную в разных местах и тогда нужно понимать, в каком порядке Ansible перезаписывает переменные.

#VSLIDE
### Приоритетность переменных

Приоритет переменных (последние значения переписывают предыдущие):
* Значения переменных в ролях
 * задачи в ролях будут видеть собственные значения. Задачи, которые определены вне роли, будут видеть последние значения переменных роли
* переменные в инвентарном файле
* переменные для группы хостов в инвентарном файле
* переменные для хостов в инвентарном файле

#VSLIDE
### Приоритетность переменных

* переменные в каталоге group_vars
* переменные в каталоге host_vars
* факты хоста
* переменные сценария (play)
* переменные сценария, которые запрашиваются через vars_prompt

#VSLIDE
### Приоритетность переменных

* переменные, которые передаются в сценарий через vars_files
* переменные полученные через параметр register
* set_facts
* переменные из роли и помещенные через include
* переменные блока (переписывают другие значения только для блока)
* переменные задачи (task) (переписывают другие значения только для задачи)
* переменные, которые передаются при вызове playbook через параметр --extra-vars (всегда наиболее приоритетные)

