# Python для сетевых инженеров 

#HSLIDE

# Регулярные выражения

#VSLIDE

### Регулярные выражения

Регулярное выражение - это последовательность из обычных и специальных символов. Эта последовательность задает шаблон, который позже используется для поиска подстрок.

При работе с сетевым оборудованием, регулярные выражения могут использоваться, например, для обработки вывода команд show.
Например, если со всего оборудования надо собрать информацию про версию ОС и uptime, можно получить эту информацию из вывода show version, обработав его с помощью регулярных выражений

В самом сетевом оборудовании, регулярные выражения можно использовать для фильтрации вывода любых команд show и more.
Или, например, для фильтрации таблицы BGP.


#HSLIDE

## Модуль re

#VSLIDE

### Модуль re

В Python для работы с регулярными выражениями используется модуль __re__.

Основные функции модуля __re__:
* ```match()``` - ищет последовательность в начале строки
* ```search()``` - ищет первое совпадение с шаблоном
* ```findall()``` - ищет все совпадения с шаблоном. Выдает результирующие строки в виде списка
* ```finditer()``` - ищет все совпадения с шаблоном. Выдает итератор
* ```compile()``` - компилирует регулярное выражение. К этому объекту затем можно применять все перечисленные функции

#VSLIDE

####```search()```

Функция ```search()```:
* используется для поиска подстроки, которая соответствует шаблону
* возвращает объект Match, если подстрока найдена
* возвращает ```None```, если подстрока не найдена

#VSLIDE
####```search()```

Поиск подстроки в строке:
```python
In [1]: import re

In [2]: line = '00:09:BB:3D:D6:58   10.1.10.2    86250   dhcp-snooping   10    FastEthernet0/1'

In [3]: print(re.search('dhcp', line))
<_sre.SRE_Match object; span=(41, 45), match='dhcp'>

In [4]: print(re.search('dhcpd', line))
None
```

#VSLIDE
####```search()```

Из объекта Match можно получить несколько вариантов полезной информации.

Например, с помощью метода ```span()```, можно получить числа, указывающие начало и конец подстроки: 
```python
In [5]: match = re.search('dhcp', line)

In [6]: match.span()
Out[6]: (41, 45)

In [7]: line[41:45]
Out[7]: 'dhcp'

```

#VSLIDE
####```search()```

Метод ```group()``` позволяет получить подстроку, которая соответствует шаблону:
```python
In [15]: match.group()
Out[15]: 'dhcp'
```

#VSLIDE
####```search()```

Важный момент в использовании функции ```search()```, то что она ищет только первое совпадение в строке, которое соответствует шаблону:
```python
In [16]: line2 = 'test dhcp, test2 dhcp2'

In [17]: match = re.search('dhcp', line2)

In [18]: match.group()
Out[18]: 'dhcp'

In [19]: match.span()
Out[19]: (5, 9)
```

#VSLIDE

####```findall()```

Для того чтобы найти все совпадения, можно использовать функцию ```findall()```:
```python
In [20]: line2 = 'test dhcp, test2 dhcp2'

In [21]: match = re.findall('dhcp', line2)

In [22]: print(match)
['dhcp', 'dhcp']
```

Особенность функции ```findall()``` в том, что она возвращает список подстрок, которые соответствуют шаблону, а не объект Match.
Поэтому нельзя вызвать методы, которые использовались в функции ```search()```.


#VSLIDE

####```finditer()```

Для того чтобы получить все совпадения, но при этом, получить совпадения в виде объекта Match(), можно использовать функцию ```finditer()```:
```python
In [23]: line2 = 'test dhcp, test2 dhcp2'

In [24]: match = re.finditer('dhcp', line2)

In [25]: print(match)
<callable-iterator object at 0x10efd2cd0>

In [26]: for i in match:
   ....:     print(i.span())
   ....:     
(5, 9)
(17, 21)

In [27]: line2[5:9]
Out[27]: 'dhcp'

In [28]: line2[17:21]
Out[28]: 'dhcp'
```

#VSLIDE

####```finditer()```

Можно воспользоваться и методами ```start()```, ```end()``` (так удобнее получить позиции подстрок):
```python
In [29]: line2 = 'test dhcp, test2 dhcp2'

In [30]: match = re.finditer('dhcp', line2)

In [31]: for i in match:
   ....:     b = i.start()
   ....:     e = i.end()
   ....:     print(line2[b:e])
   ....:     
dhcp
dhcp
```

#VSLIDE

####```compile()```

В Python есть возможность заранее скомпилировать регулярное выражение, а затем использовать его. Это особенно полезно в тех случаях, когда регулярное выражение много используется в скрипте.

Пример компиляции регулярного выражения и его использования:
```python
In [32]: line2 = 'test dhcp, test2 dhcp2'

In [33]: regex = re.compile('dhcp')

In [34]: match = regex.finditer(line2)

In [35]: for i in match:
   ....:     b = i.start()
   ....:     e = i.end()
   ....:     print(line2[b:e])
   ....:     
dhcp
dhcp
```

#HSLIDE

## Специальные символы

#VSLIDE
### Специальные символы

Полностью возможности регулярных выражений проявляются при использовании специальных символов.

Специальные символы:
* ```.``` - любой символ, кроме символа новой строки (опция m позволяет включить и символ новой строки)
* ```^``` - начало строки
* ```$``` - конец строки
* ```[abc]``` - любой символ в скобках
* ```[^abc]``` - любой символ, кроме тех, что в скобках
* ```a|b``` - элемент a или b
* ```(regex)``` - выражение рассматривается как один элемент. Текст, который совпал с выражением, запоминается

#VSLIDE
### Специальные символы

Повторение:
* ```regex*``` - ноль или более повторений предшествующего элемента
* ```regex+``` - один или более повторений предшествующего элемента
* ```regex?``` - ноль или одно повторение предшествующего элемента
* ```regex{n}``` - ровно n повторений предшествующего элемента
* ```regex{n,m}``` - от n до m повторений предшествующего элемента
in [6]: match.span()
Out[6]: (49, 53)

In [7]: line[49:53]
Out[7]: 'dhcp'
* ```regex{n, }``` - n или более повторений предшествующего элемента

#VSLIDE
### Специальные символы

Предопределенные наборы символов:
* ```\d``` - любая цифра
* ```\D``` - любое нечисловое значение
* ```\s``` - whitespace (\t\n\r\f\v)
* ```\S``` - все, кроме whitespace
* ```\w``` - любая буква или цифра
* ```\W``` - все, кроме букв и цифр

#VSLIDE
### Специальные символы

Посмотрим на примеры использования специальных символов:
```python
In [1]: import re

In [2]: line = "FastEthernet0/1            10.0.12.1       YES manual up                    up"
```

Точка обозначает любой символ, поэтому в строке line найдено 3 совпадения с регулярным выражением ```.0```:
```python
In [3]: prine(re.findall('.0', line))
['t0', '10', '.0']
```

#VSLIDE
### Специальные символы

Символ ```^``` означает начало строки. Выражению ```^F``` соотвествует только одна подстрока:
```python
In [4]: print(re.findall('^F', line))
['F']
```

Выражению ```^.a``` соответствует подстрока 'Fa':
```python
In [5]: print(re.findall('^.a', line))
['Fa']
```

#VSLIDE
### Специальные символы

Символ ```$``` обозначает конец строки:
```python
In [6]: print(re.findall('up$', line))
['up']

In [7]: print(re.findall('up', line))
['up', 'up']
```

#VSLIDE
### Специальные символы

Символы, которые перечислены в квадратных скобках, означают, что любой из этим символов будет совпадением.
Таким образом можно описывать разные регистры:
```python
In [8]: print(re.findall('[Ff]ast', line))
['Fast']

In [9]: print(re.findall('[Ff]ast[Ee]thernet', line))
['FastEthernet']
```

#VSLIDE
### Специальные символы

Если после открывающейся квадратной скобки, указан символ ```^```, совпадением будет любой символ, кроме указанных в скобках (в данном случае, всё, кроме букв и пробела):
```python
In [10]: print(re.findall('[^a-zA-Z ]', line))
['0', '/', '1', '1', '0', '.', '0', '.', '1', '2', '.', '1']
```

Вертикальная черта работает как 'или':
```python
In [11]: print(re.findall('up|down', line))
['up', 'up']
```

#HSLIDE

## Жадность регулярных выражений

#VSLIDE

### Жадность регулярных выражений

По умолчанию, символы повторения в регулярных выражениях жадные (greedy).
Это значит, что результирующая подстрока, которая соответствует шаблону, будет наиболее длинной.

Пример жадного поведения:
```python
In [1]: import re
In [2]: line = '<text line> some text>'
In [3]: match = re.search('<.*>', line)

In [4]: match.group()
Out[4]: '<text line> some text>'
```

То есть, в даном случае выражение захватило максимально возможный кусок символов, заключенный в <>.

#VSLIDE

### Жадность регулярных выражений

Если нужно отключить жадность, достаточно добавить знак вопроса после символов повторения:
```python
In [5]: line = '<text line> some text>'

In [6]: match = re.search('<.*?>', line)

In [7]: match.group()
Out[7]: '<text line>'
```

#HSLIDE

## Группировка выражений

#VSLIDE

### Нумерованные группы

С помощью определения групп элементов в шаблоне, можно изолировать части текста, которые соответствуют шаблону.

Группа определяется помещением выражения в круглые скобки ```()```. 

Внутри выражения, группы нумеруются слева направо, начиная с 1.
Затем к группам можно обращаться по номерам и получать текст, которые соответствует выражению в группе.

#VSLIDE

### Нумерованные группы

Пример использования групп:
```python
In [8]: line = "FastEthernet0/1            10.0.12.1       YES manual up                    up"
In [9]: match = re.search('(\S+?)\s+([\w\.]+?)\s+.*', line)
```

В данном примере указаны две группы:
* первая группа - любые символы, кроме whitespaces. Эта группа не жадная
* вторая группа - любая буква или цифра (символ ```\w```) или точка. Эта группа не жадная

#VSLIDE

### Нумерованные группы

Теперь можно обращаться к группам по номеру. Группа 0 это строка, которая соответствует всему шаблону:
```python
In [10]: match.group(0)
Out[10]: 'FastEthernet0/1            10.0.12.1       YES manual up                    up'

In [11]: match.group(1)
Out[11]: 'FastEthernet0/1'

In [12]: match.group(2)
Out[12]: '10.0.12.1'
```

#VSLIDE

### Нумерованные группы

Для вывода всех подстрок, которые соответствуют указанным группам, используется метод groups:
```python
In [13]: match.groups()
Out[13]: ('FastEthernet0/1', '10.0.12.1')
```

#VSLIDE

### Именованные группы

Когда выражение сложное, не очень удобно определять номер группы.
Плюс, при дополнении выражения, может получиться так, что порядок групп изменился.
И придется изменить и код, который ссылается на группы.

Именованные группы позволяют задавать группе имя.

#VSLIDE

### Именованные группы

Синтаксис именованной группы __```(?P<name>regex)```__:
```python
In [14]: line = "FastEthernet0/1            10.0.12.1       YES manual up                    up"

In [15]: match = re.search('(?P<intf>\S+?)\s+(?P<address>[\w\.]+?)\s+.*', line)
```

Теперь к этим группам можно обращаться по имени:
```python
In [15]: match.group('intf')
Out[15]: 'FastEthernet0/1'

In [16]: match.group('address')
Out[16]: '10.0.12.1'
```

#VSLIDE

### Именованные группы

Также очень полезно то, что с помощью метода groupdict(), можно получить словарь, где ключи - имена групп, а значения - подстроки, которые им соответствуют:
```python
In [17]: match.groupdict()
Out[17]: {'address': '10.0.12.1', 'intf': 'FastEthernet0/1'}
```

И, в таком случае, можно добавить группы в регулярное выражение и полагаться на их имя, а не на порядок:
```python
In [18]: match = re.search('(?P<intf>\S+?)\s+(?P<address>[\w\.]+?)\s+(?P<status>up|down|administratively down)\s+(?P<protocol>up|down)', line)

In [19]: match.groupdict()
Out[19]: {'address': 'manual', 'intf': 'YES', 'protocol': 'up', 'status': 'up'}
```

#HSLIDE
### Разбор вывода команды show ip dhcp snooping с помощью именованных групп

#VSLIDE

### Разбор вывода команды show ip dhcp snooping с помощью именованных групп

В этом примере, задача в том, чтобы получить из вывода команды show ip dhcp snooping binding
поля: MAC-адрес, IP-адрес, VLAN и интерфейс.


В файле dhcp_snooping.txt находится вывод команды show ip dhcp snooping binding: 
```
MacAddress          IpAddress        Lease(sec)  Type           VLAN  Interface
------------------  ---------------  ----------  -------------  ----  --------------------
00:09:BB:3D:D6:58   10.1.10.2        86250       dhcp-snooping   10    FastEthernet0/1
00:04:A3:3E:5B:69   10.1.5.2         63951       dhcp-snooping   5     FastEthernet0/10
00:05:B3:7E:9B:60   10.1.5.4         63253       dhcp-snooping   5     FastEthernet0/9
00:09:BC:3F:A6:50   10.1.10.6        76260       dhcp-snooping   10    FastEthernet0/3
Total number of bindings: 4
```

#VSLIDE

Для начала, попробуем разобрать одну строку:
```python
In [1]: line = '00:09:BB:3D:D6:58  10.1.10.2 86250   dhcp-snooping   10  FastEthernet0/1'
```

В регулярном выражении, именованные группы используются для тех частей вывода, которые нужно запомнить:
```python
In [2]: match = re.search(r'(?P<mac>.+?) +(?P<ip>.*?) +(\d+) +([\w-]+) +(?P<vlan>\d+) +(?P<int>.*$)', line)
```

#VSLIDE

Комментарии к регулярному выражению (что попадет в группу):
* ```(?P<mac>.+?) +``` - любые символы, до пробела
* ```(?P<ip>.*?) +``` - любые символы, до пробела
* ```(\d+) +``` - одна или более цифр
* ```([\w-]+) +``` - буквы или ```-```, в количестве одного или более
* ```(?P<vlan>\d+) +``` - одна или более цифр
* ```(?P<int>.*$)``` - любые символы, которые находятся в конце строки

Обратите внимание, что для первых двух групп элементов отключена жадность.

Для остальных жадность можно не отключать, так как в них более четко указаны какие именно символы должны быть.

#VSLIDE

В результате, метод groupdict вернет такой словарь:
```python
In [3]: match.groupdict()
Out[3]: 
{'int': 'FastEthernet0/1',
 'ip': '10.1.10.2',
 'mac': '00:09:BB:3D:D6:58',
 'vlan': '10'}
```

#VSLIDE

Файл parse_dhcp_snooping.py:
```python
# -*- coding: utf-8 -*-
import re

regex = re.compile('(?P<mac>.+?) +(?P<ip>.*?) +(\d+) +([\w-]+) +(?P<vlan>\d+) +(?P<int>.*$)')
result = []

with open('dhcp_snooping.txt') as data:
    for line in data:
        if line[0].isdigit():
            result.append(regex.search(line).groupdict())

print("К коммутатору подключено {} устройства".format(len(result)))

for num, comp in enumerate(result, 1):
    print("Параметры устройства {}:".format(num))
    for key in comp:
        print("{:10}: {:10}".format(key,comp[key]))
```

#VSLIDE

Результат выполнения:
```
$ python parse_dhcp_snooping.py
К коммутатору подключено 4 устройства
Параметры устройства 1:
	int:	FastEthernet0/1
	ip:	10.1.10.2
	mac:	00:09:BB:3D:D6:58
	vlan:	10
Параметры устройства 2:
	int:	FastEthernet0/10
	ip:	10.1.5.2
	mac:	00:04:A3:3E:5B:69
	vlan:	5
Параметры устройства 3:
	int:	FastEthernet0/9
	ip:	10.1.5.4
	mac:	00:05:B3:7E:9B:60
	vlan:	5
Параметры устройства 4:
	int:	FastEthernet0/3
	ip:	10.1.10.6
	mac:	00:09:BC:3F:A6:50
	vlan:	10
```

